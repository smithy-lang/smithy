<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>AbstractCodeWriter (Smithy API 1.51.0)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="AbstractCodeWriter (Smithy API 1.51.0)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":9,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":10,"i52":10,"i53":10,"i54":10,"i55":10,"i56":10,"i57":10,"i58":10,"i59":10,"i60":10,"i61":10,"i62":10,"i63":10,"i64":10,"i65":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">software.amazon.smithy.utils</a></div>
<h2 title="Class AbstractCodeWriter" class="title">Class AbstractCodeWriter&lt;T extends AbstractCodeWriter&lt;T&gt;&gt;</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>software.amazon.smithy.utils.AbstractCodeWriter&lt;T&gt;</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="CodeWriter.html" title="class in software.amazon.smithy.utils">CodeWriter</a></code>, <code><a href="SimpleCodeWriter.html" title="class in software.amazon.smithy.utils">SimpleCodeWriter</a></code>, <code><a href="../codegen/core/SymbolWriter.html" title="class in software.amazon.smithy.codegen.core">SymbolWriter</a></code>, <code><a href="../codegen/core/writer/SymbolWriter.html" title="class in software.amazon.smithy.codegen.core.writer">SymbolWriter</a></code></dd>
</dl>
<hr>
<pre>public abstract class <span class="typeNameLabel">AbstractCodeWriter&lt;T extends AbstractCodeWriter&lt;T&gt;&gt;</span>
extends java.lang.Object</pre>
<div class="block">Helper class for generating code.

 <p>An AbstractCodeWriter can be used to write basically any kind of code, including
 whitespace sensitive and brace-based.

 <p>The following example generates some Python code:

 <pre><code>
 SimpleCodeWriter writer = new SimpleCodeWriter();
 writer.write("def Foo(str):")
       .indent()
       .write("print str");
 String code = writer.toString();
 </code></pre>

 <h2>Code interpolation</h2>

 <p>The <a href="#write(java.lang.Object,java.lang.Object...)"><code>write(java.lang.Object, java.lang.Object...)</code></a>, <a href="#openBlock(java.lang.String,java.lang.Object...)"><code>openBlock(java.lang.String, java.lang.Object...)</code></a>, and <a href="#closeBlock(java.lang.String,java.lang.Object...)"><code>closeBlock(java.lang.String, java.lang.Object...)</code></a> methods
 take a code expression and a variadic list of arguments that are
 interpolated into the expression. Consider the following call to
 <code>write</code>:

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 writer.write("Hello, $L", "there!");
 String code = writer.toString();
 </code></pre>

 <p>In the above example, <code>$L</code> is interpolated and replaced with the
 relative argument <code>there!</code>.

 <p>An AbstractCodeWriter supports three kinds of interpolations: relative,
 positional, and named. Each of these kinds of interpolations pass a value
 to a <em>formatter</em>.</p>

 <h3>Formatters</h3>

 <p>Formatters are named functions that accept an object as input, accepts a
 string that contains the current indentation (it can be ignored if not useful),
 and returns a string as output. <code>AbstractCodeWriter</code> registers two built-in
 formatters:

 <ul>
     <li><code>L</code> (literal): Outputs a literal value of an <code>Object</code> using
     the following implementation: (1) A null value is formatted as "".
     (2) An empty <code>Optional</code> value is formatted as "". (3) A non-empty
     <code>Optional</code> value is recursively formatted using the value inside
     of the <code>Optional</code>. (3) All other valeus are formatted using the
     result of calling <code>String.valueOf(java.lang.Object)</code>.</li>

     <li><code>C</code> (call): Runs a <code>Runnable</code> or <code>Consumer</code> argument
     that is expected to write to the same writer. Any text written to the AbstractCodeWriter
     inside of the Runnable is used as the value of the argument. Note that a
     single trailing newline is removed from the captured text. If a Runnable is
     provided, it is required to have a reference to the AbstractCodeWriter. A Consumer
     is provided a reference to the AbstractCodeWriter as a single argument.

     <pre><code>
     SimpleCodeWriter writer = new SimpleCodeWriter();
     writer.write("Hello, $C.", (Runnable) () -&gt; writer.write("there"));
     assert(writer.toString().equals("Hello, there.\n"));
     </code></pre></li>

     <li><code>S</code> (string): Adds double quotes around the result of formatting a
     value first using the default literal "L" implementation described
     above and then wrapping the value in an escaped string safe for use in
     Java according to https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6.
     This formatter can be overridden if needed to support other
     programming languages.</li>
 </ul>

 <p>Custom formatters can be registered using <a href="#putFormatter(char,java.util.function.BiFunction)"><code>putFormatter(char, java.util.function.BiFunction&lt;java.lang.Object, java.lang.String, java.lang.String&gt;)</code></a>. Custom
 formatters can be used only within the state they were added. Because states
 inherit the formatters of parent states, adding a formatter to the root state
 of the AbstractCodeWriter allows the formatter to be used in any state.

 <p>The identifier given to a formatter must match one of the following
 characters:

 <pre>
    "!" / "#" / "%" / "&amp;" / "*" / "+" / "," / "-" / "." / "/" / ";"
  / "=" / "?" / "@" / "A" / "B" / "C" / "D" / "E" / "F" / "G" / "H"
  / "I" / "J" / "K" / "L" / "M" / "N" / "O" / "P" / "Q" / "R" / "S"
  / "T" / "U" / "V" / "W" / "X" / "Y" / "Z" / "^" / "_" / "`" / "~"
 </pre>

 <h3>Relative parameters</h3>

 <p>Placeholders in the form of "$" followed by a formatter name are treated
 as relative parameters. The first instance of a relative parameter
 interpolates the first positional argument, the second the second, etc.

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 writer.write("$L $L $L", "a", "b", "c");
 System.out.println(writer.toString());
 // Outputs: "a b c"
 </code></pre>

 <p>All relative arguments must be used as part of an expression and
 relative interpolation cannot be mixed with positional variables.

 <h3>Positional parameters</h3>

 <p>Placeholders in the form of "$" followed by a positive number,
 followed by a formatter name are treated as positional parameters. The
 number refers to the 1-based index of the argument to interpolate.

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 writer.write("$1L $2L $3L, $3L $2L $1L", "a", "b", "c");
 System.out.println(writer.toString());
 // Outputs: "a b c c b a"
 </code></pre>

 <p>All positional arguments must be used as part of an expression
 and relative interpolation cannot be mixed with positional variables.

 <h3>Named parameters</h3>

 <p>Named parameters are parameters that take a value from the context bag of
 the current state or using getters of the <a href="CodeSection.html" title="interface in software.amazon.smithy.utils"><code>CodeSection</code></a> associated with
 the current state. They take the following form <code>$&lt;variable&gt;:&lt;formatter&gt;</code>,
 where <code>&lt;variable&gt;</code> is a string that starts with a lowercase letter,
 followed by any number of <code>[A-Za-z0-9_#$.]</code> characters, and
 <code>&lt;formatter&gt;</code> is the name of a formatter.

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 writer.putContext("foo", "a");
 writer.putContext("baz.bar", "b");
 writer.write("$foo:L $baz.bar:L");
 System.out.println(writer.toString());
 // Outputs: "a b"
 </code></pre>

 <p>The context bag is checked first, and then if the parameter is not found,
 getters of the currently associated CodeSection are checked. If a getter is
 found that matches the key exactly, then that getter is invoked and used as
 the named parameter. If a getter is found that matches
 "get" + uppercase_first_letter(key), then that getter is used as the named
 parameter.

 <h3>Escaping interpolation</h3>

 <p>You can escape the "$" character using two "$$".

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter().write("$$L");
 System.out.println(writer.toString());
 // Outputs: "$L"
 </code></pre>

 <h3>Custom expression characters</h3>

 <p>The character used to start a code block expression can be customized
 to make it easier to write code that makes heavy use of <code>$</code>. The
 default character used to start an expression is, <code>$</code>, but this can
 be changed for the current state of the AbstractCodeWriter by calling
 <a href="#setExpressionStart(char)"><code>setExpressionStart(char)</code></a>. A custom start character can be escaped
 using two start characters in a row. For example, given a custom start
 character of <code>#</code>, <code>#</code> can be escaped using <code>##</code>.

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 writer.setExpressionStart('#');
 writer.write("#L ##L $L", "hi");
 System.out.println(writer.toString());
 // Outputs: "hi #L $L"
 </code></pre>

 <em>The start character cannot be set to ' ' or '\n'.</em>

 <h2>Opening and closing blocks</h2>

 <p><code>AbstractCodeWriter</code> provides a short cut for opening code blocks that
 have an opening an closing delimiter (for example, "{" and "}") and that
 require indentation inside of the delimiters. Calling <a href="#openBlock(java.lang.String,java.lang.Object...)"><code>openBlock(java.lang.String, java.lang.Object...)</code></a>
 and providing the opening statement will write and format a line followed
 by indenting one level. Calling <a href="#closeBlock(java.lang.String,java.lang.Object...)"><code>closeBlock(java.lang.String, java.lang.Object...)</code></a> will first dedent and
 then print a formatted statement.

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter()
       .openBlock("if ($L) {", someValue)
       .write("System.out.println($S);", "Hello!")
       .closeBlock("}");
 </code></pre>

 <p>The above example outputs (assuming someValue is equal to "foo"):

 <pre><code>
 if (foo) {
     System.out.println("Hello!");
 }
 </code></pre>

 <h2>Pushing and popping state</h2>

 <p>AbstractCodeWriter can maintain a stack of transformation states, including
 the text used to indent, a prefix to add before each line, newline character,
 the number of times to indent, a map of context values, whether or not
 whitespace is trimmed from the end of newlines, whether or not the automatic
 insertion of newlines is disabled, the character used to start code
 expressions (defaults to <code>$</code>), and formatters. State can be pushed onto
 the stack using <a href="#pushState()"><code>pushState()</code></a> which copies the current state. Mutations
 can then be made to the top-most state of the AbstractCodeWriter and do not affect
 previous states. The previous transformation state of the AbstractCodeWriter can later
 be restored using <a href="#popState()"><code>popState()</code></a>.

 <p>AbstractCodeWriter is stateful, and a prefix can be added before each line.
 This is useful for doing things like create Javadoc strings:

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 writer
       .pushState()
       .write("/**")
       .setNewlinePrefix(" * ")
       .write("This is some docs.")
       .write("And more docs.\n\n\n")
       .write("Foo.")
       .popState()
       .write(" *\/");
 </code></pre>

 <p>The above example outputs:

 <pre><code>
 /**
  * This is some docs.
  * And more docs.
  *
  * Foo.
  *\/

   ^ Minus this escape character
 </code></pre>

 <p>AbstractCodeWriter maintains some global state that is not affected by
 <a href="#pushState()"><code>pushState()</code></a> and <a href="#popState()"><code>popState()</code></a>:

 <ul>
     <li>The number of successive blank lines to trim.</li>
     <li>Whether or not a trailing newline is inserted or removed from
     the result of converting the <code>AbstractCodeWriter</code> to a string.</li>
 </ul>

 <h2>Limiting blank lines</h2>

 <p>Many coding standards recommend limiting the number of successive blank
 lines. This can be handled automatically by <code>AbstractCodeWriter</code> by calling
 <code>trimBlankLines</code>. The removal of blank lines is handled when the
 <code>AbstractCodeWriter</code> is converted to a string. Lines that consist solely
 of spaces or tabs are considered blank. If the number of blank lines
 exceeds the allowed threshold, they are omitted from the result.

 <h2>Trimming trailing spaces</h2>

 <p>Trailing spaces can be automatically trimmed from each line by calling
 <a href="#trimTrailingSpaces()"><code>trimTrailingSpaces()</code></a>.

 <p>In the following example:

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 String result = writer.trimTrailingSpaces().write("hello  ").toString();
 </code></pre>

 <p>The value of <code>result</code> contains <code>"hello"</code>

 <h2>Extending AbstractCodeWriter</h2>

 <p><code>AbstractCodeWriter</code> can be extended to add functionality for specific
 programming languages. For example, Java specific code generator could
 be implemented that makes it easier to write Javadocs.

 <pre><code>
 class JavaCodeWriter extends AbstractCodeWriter&lt;JavaCodeWriter&gt; {
     public JavaCodeWriter javadoc(Runnable runnable) {
         pushState()
         write("/**")
         setNewlinePrefix(" * ")
         runnable.run();
         popState()
         write(" *\/");
         return this;
     }
 }

 JavaCodeWriter writer = new JavaCodeWriter();
 writer.javadoc(() -&gt; {
     writer.write("This is an example.");
 });
 </code></pre>

 <h2>Code sections</h2>

 <p>Named sections can be marked in the code writer that can be intercepted
 and modified by <em>section interceptors</em>. This gives the
 <code>AbstractCodeWriter</code> a lightweight extension system for augmenting generated
 code.

 <p>A section of code can be captured using a block state or an inline
 section. Section names must match the following regular expression:
 <code>^[a-z]+[a-zA-Z0-9_.#$]*$</code>.

 <h3>Block states</h3>

 <p>A block section is created by passing a string to <a href="#pushState()"><code>pushState()</code></a>.
 This string gives the state a name and captures all of the output written
 inside of this state to an internal buffer. This buffer is then passed to
 each registered interceptor for that name. These interceptors can choose
 to use the default contents of the section or emit entirely different
 content. Interceptors are expected to make calls to the <code>AbstractCodeWriter</code>
 in order to emit content. Interceptors need to have a reference to the
 <code>AbstractCodeWriter</code> as one is not provided to them when they are invoked.
 Interceptors are invoked in the order in which they are added to the
 <code>CodeBuilder</code>.

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 writer.onSection("example", text -&gt; writer.write("Intercepted: " + text));
 writer.pushState("example");
 writer.write("Original contents");
 writer.popState();
 System.out.println(writer.toString());
 // Outputs: "Intercepted: Original contents\n"
 </code></pre>

 <h3>Inline sections</h3>

 An inline section is created using a special <code>CodeWriter</code> interpolation
 format that appends "@" followed by the section name. Inline sections are
 function just like block sections, but they can appear inline inside of
 other content passed in calls to <a href="#write(java.lang.Object,java.lang.Object...)"><code>write(java.lang.Object, java.lang.Object...)</code></a>. An inline section
 that makes no calls to <a href="#write(java.lang.Object,java.lang.Object...)"><code>write(java.lang.Object, java.lang.Object...)</code></a> expands to an empty string.

 <p>Inline sections are created in a format string inside of braced arguments
 after the formatter. For example, <code>${L@foo}</code> is an inline section
 that uses the literal "L" value of a relative argument as the default value
 of the section and allows AbstractCodeWriter registered for the "foo" section to
 make calls to the <code>CodeWriter</code> to modify the section.

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 writer.onSection("example", text -&gt; writer.write("Intercepted: " + text));
 writer.write("Leading text...${L@example}...Trailing text...", "foo");
 System.out.println(writer.toString());
 // Outputs: "Leading text...Intercepted: foo...Trailing text...\n"
 </code></pre>

 Inline sections are useful for composing sets or lists from any code with access to <code>AbstractCodeWriter</code>:

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 writer.onSection("example", text -&gt; writer.write(text + "1, "));
 writer.onSection("example", text -&gt; writer.write(text + "2, "));
 writer.onSection("example", text -&gt; writer.write(text + "3"));
 writer.write("[${L@example}]", "");
 System.out.println(writer.toString());
 // Outputs: "[1, 2, 3]\n"
 </code></pre>

 <h3>Inline block alignment</h3>

 <p>The long-form interpolation syntax allows for
 <em>inline block alignment</em>, which means that any newline emitted by
 the interpolation is automatically aligned with the column of where the
 interpolation occurs. Inline block indentation is defined by preceding
 the closing '}' character with '|' (e.g., <code>${L|}</code>):

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 writer.write("$L: ${L|}", "Names", "Bob\nKaren\nLuis");
 System.out.println(writer.toString());
 // Outputs: "Names: Bob\n       Karen\n       Luis\n"
 </code></pre>

 <p>Alignment occurs either statically or dynamically based on the characters
 that come before interpolation. If all of the characters in the literal
 template that come before interpolation are spaces and tabs, then those
 characters are used when indenting newlines. Otherwise, the number of
 characters written as the template result that come before interpolation
 are used when indenting (this takes into account any interpolation that
 may precede block interpolation).

 <p>Block interpolation is particularly used when using text blocks in Java
 because it allows templates to more closely match their end result.

 <pre><code>
 // Assume handleNull, handleA, and handleB are Runnable.
 writer.write("""
     if (foo == null) {
         ${C|}
     } else if (foo == "a") {
         ${C|}
     } else if (foo == "b") {
         ${C|}
     }
     """,
     handleNull,
     handleA,
     handleB);
 </code></pre>

 <h3>Template conditionals and loops</h3>

 <p>AbstractCodeWriter is a lightweight template engine that supports conditional
 blocks and loops.

 <h4>Conditional blocks</h4>

 <p>Conditional blocks are defined using the following syntax:

 <pre><code>
 ${?foo}
 Foo is set: ${foo:L}
 ${/foo}
 </code></pre>

 <p>Assuming <code>foo</code> is truthy and set to "hi", then the above template
 outputs: "Foo is set: hi"

 <p>In the above example, "?" indicates that the expression is a conditional block
 to check if the named parameter "foo" is truthy. If it is, then the contents of the
 block up to the matching closing block, <code>${/foo}</code>, are evaluated. If the
 condition is not satisfied, then contents of the block are skipped.

 <p>You can check if a named property is falsey using "^":

 <pre><code>
 ${^foo}
 Foo is not set
 ${/foo}
 </code></pre>

 <p>Assuming <code>foo</code> is set to "hi", then the above template outputs nothing.
 If <code>foo</code> is falsey, then the above template output "Foo is not set".

 <h4>Truthy and falsey</h4>

 <p>The following values are considered falsey:

 <ul>
     <li>values that are not found</li>
     <li>null values</li>
     <li>false</li>
     <li>empty <code>String</code></li>
     <li>empty <code>Iterable</code></li>
     <li>empty <code>Map</code></li>
     <li>empty <code>Optional</code></li>
 </ul>

 <p>Values that are not falsey are considered truthy.

 <h4>Loops</h4>

 <p>Loops can be created to repeat a section of a template for each value stored in
 a list or each each key value pair stored in a map. Loops are created using "#".

 <p>The following template with a "foo" value of {"key1": "a", "key2": "b", "key3": "c"}:

 <pre><code>
 ${#foo}
 - ${key:L}: ${value:L} (first: ${key.first:L}, last: ${key.last:L})
 ${/foo}
 </code></pre>

 <p>Evaluates to:</p>

 <pre><code>
 - key1: a (first: true, last: false)
 - key2: b (first: false, last: false)
 - key3: c (first: false, last: true)
 </code></pre>

 <p>Each iteration of the loop pushes a new state in the writer that sets the following
 context properties:

 <ul>
     <li>key: contains the current 0-based index of an iterator or the current key of a map entry</li>
     <li>value: contains the current value of an iterator or current value of a map entry</li>
     <li>key.first: set to true if the loop is on the first iteration</li>
     <li>key.false: set to true if the loop is on the last iteration</li>
 </ul>

 <p>A custom variable name can be used in loops. For example:

 <pre><code>
 ${#foo as key1, value1}
     - ${key1:L}: ${value1:L} (first: ${key1.first:L}, last: ${key1.last:L})
 ${/foo}
 </code></pre>

 <h4>Whitespace control</h4>

 <p>Conditional blocks that occur on lines that only contain whitespace are not written
 to the template output. For example, if the condition in the following template evaluates
 to falsey, then the template expands to an empty string:

 <pre><code>
 ${?foo}
 Foo is set: ${foo:L}
 ${/foo}
 </code></pre>

 <p>Whitespace that comes before an expression can be removed by putting "~" at the beginning of an expression.

 <p>Assuming that the first positional argument is "hi":

 <pre><code>
 Greeting:
     ${~L}
 </code></pre>

 <p>Expands to:

 <pre><code>
 Greeting:hi
 </code></pre>

 <p>Whitespace that comes after an expression can be removed by adding "~" to the end of the expression:

 <pre><code>
 ${L~}

 .
 </code></pre>

 <p>Expands to:

 <pre><code>
 hi.
 </code></pre>

 <p>Leading whitespace cannot be removed when using inline block alignment ('|'). The following is invalid:

 <pre><code>
 ${~C|}
 </code></pre></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">AbstractCodeWriter</a></span>()</code></th>
<td class="colLast">
<div class="block">Creates a new SimpleCodeWriter that uses "\n" for a newline, four spaces
 for indentation, does not strip trailing whitespace, does not flatten
 multiple successive blank lines into a single blank line, and adds no
 trailing new line.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#call(java.lang.Runnable)">call</a></span>&#8203;(java.lang.Runnable&nbsp;task)</code></th>
<td class="colLast">
<div class="block">Allows calling out to arbitrary code for things like looping or
 conditional writes without breaking method chaining.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#closeBlock(java.lang.String,java.lang.Object...)">closeBlock</a></span>&#8203;(java.lang.String&nbsp;textAfterNewline,
          java.lang.Object...&nbsp;args)</code></th>
<td class="colLast">
<div class="block">Closes a block of syntax by writing a newline, dedenting, then writing text.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>java.util.function.Consumer&lt;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#consumer(java.util.function.Consumer)">consumer</a></span>&#8203;(java.util.function.Consumer&lt;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&gt;&nbsp;consumer)</code></th>
<td class="colLast">
<div class="block">A simple helper method that makes it easier to invoke the built-in <code>C</code>
 (call) formatter using a <code>Consumer</code> where <code>T</code> is the specific type
 of <a href="AbstractCodeWriter.html" title="class in software.amazon.smithy.utils"><code>AbstractCodeWriter</code></a>.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#copySettingsFrom(software.amazon.smithy.utils.AbstractCodeWriter)">copySettingsFrom</a></span>&#8203;(<a href="AbstractCodeWriter.html" title="class in software.amazon.smithy.utils">AbstractCodeWriter</a>&lt;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">Copies settings from the given AbstractCodeWriter into this AbstractCodeWriter.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dedent()">dedent</a></span>()</code></th>
<td class="colLast">
<div class="block">Removes one level of indentation from all lines.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dedent(int)">dedent</a></span>&#8203;(int&nbsp;levels)</code></th>
<td class="colLast">
<div class="block">Removes a specific number of indentations from all lines.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#disableNewlines()">disableNewlines</a></span>()</code></th>
<td class="colLast">
<div class="block">Disables the automatic appending of newlines in the current state.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#enableNewlines()">enableNewlines</a></span>()</code></th>
<td class="colLast">
<div class="block">Enables the automatic appending of newlines in the current state.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#enableStackTraceComments(boolean)">enableStackTraceComments</a></span>&#8203;(boolean&nbsp;enableStackTraceComments)</code></th>
<td class="colLast">
<div class="block">Enable or disable writing stack trace comments before each call to
 <a href="#write(java.lang.Object,java.lang.Object...)"><code>write(java.lang.Object, java.lang.Object...)</code></a>, <a href="#writeWithNoFormatting(java.lang.Object)"><code>writeWithNoFormatting(java.lang.Object)</code></a>, <a href="#writeInline(java.lang.Object,java.lang.Object...)"><code>writeInline(java.lang.Object, java.lang.Object...)</code></a>,
 and <a href="#writeInlineWithNoFormatting(java.lang.Object)"><code>writeInlineWithNoFormatting(java.lang.Object)</code></a>.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ensureNewline()">ensureNewline</a></span>()</code></th>
<td class="colLast">
<div class="block">Ensures that the last text written to the writer was a newline as defined in
 the current state and inserts one if necessary.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#format(java.lang.Object,java.lang.Object...)">format</a></span>&#8203;(java.lang.Object&nbsp;content,
      java.lang.Object...&nbsp;args)</code></th>
<td class="colLast">
<div class="block">Creates a formatted string using formatter expressions and variadic
 arguments.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#formatLiteral(java.lang.Object)">formatLiteral</a></span>&#8203;(java.lang.Object&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Provides the default functionality for formatting literal values.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>protected java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#formatWithStackTraceElement(java.lang.String,java.lang.StackTraceElement,boolean)">formatWithStackTraceElement</a></span>&#8203;(java.lang.String&nbsp;content,
                           java.lang.StackTraceElement&nbsp;element,
                           boolean&nbsp;inline)</code></th>
<td class="colLast">
<div class="block">Formats content for the given stack frame.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getContext(java.lang.String)">getContext</a></span>&#8203;(java.lang.String&nbsp;key)</code></th>
<td class="colLast">
<div class="block">Gets a named contextual key-value pair from the current state or any parent states.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>&lt;C&gt;&nbsp;C</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getContext(java.lang.String,java.lang.Class)">getContext</a></span>&#8203;(java.lang.String&nbsp;key,
          java.lang.Class&lt;C&gt;&nbsp;type)</code></th>
<td class="colLast">
<div class="block">Gets a named context key-value pair from the current state and
 casts the value to the given type.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="CodeWriterDebugInfo.html" title="class in software.amazon.smithy.utils">CodeWriterDebugInfo</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDebugInfo()">getDebugInfo</a></span>()</code></th>
<td class="colLast">
<div class="block">Gets debug information about the current state of the AbstractCodeWriter, including
 the path to the current state as returned by <code>getStateDebugPath()</code>,
 and up to the last two lines of text written to the AbstractCodeWriter.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="CodeWriterDebugInfo.html" title="class in software.amazon.smithy.utils">CodeWriterDebugInfo</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDebugInfo(int)">getDebugInfo</a></span>&#8203;(int&nbsp;numberOfContextLines)</code></th>
<td class="colLast">
<div class="block">Gets debug information about the current state of the AbstractCodeWriter.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>char</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getExpressionStart()">getExpressionStart</a></span>()</code></th>
<td class="colLast">
<div class="block">Get the expression start character of the <em>current</em> state.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getIndentLevel()">getIndentLevel</a></span>()</code></th>
<td class="colLast">
<div class="block">Gets the indentation level of the current state.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getIndentText()">getIndentText</a></span>()</code></th>
<td class="colLast">
<div class="block">Gets the text used for indentation (defaults to four spaces).</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getInsertTrailingNewline()">getInsertTrailingNewline</a></span>()</code></th>
<td class="colLast">
<div class="block">Checks if the AbstractCodeWriter inserts a trailing newline (if necessary) when
 converted to a string.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getNewline()">getNewline</a></span>()</code></th>
<td class="colLast">
<div class="block">Gets the character used to represent newlines in the current state.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getNewlinePrefix()">getNewlinePrefix</a></span>()</code></th>
<td class="colLast">
<div class="block">Gets the prefix to prepend to every line after a new line is added
 (except for an inserted trailing newline).</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getTrimBlankLines()">getTrimBlankLines</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns the number of allowed consecutive newlines that are not
 trimmed by the AbstractCodeWriter when written to a string.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getTrimTrailingSpaces()">getTrimTrailingSpaces</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns true if the trailing spaces in the current state are trimmed.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#indent()">indent</a></span>()</code></th>
<td class="colLast">
<div class="block">Indents all text one level.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#indent(int)">indent</a></span>&#8203;(int&nbsp;levels)</code></th>
<td class="colLast">
<div class="block">Indents all text a specific number of levels.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#injectSection(software.amazon.smithy.utils.CodeSection)">injectSection</a></span>&#8203;(<a href="CodeSection.html" title="interface in software.amazon.smithy.utils">CodeSection</a>&nbsp;section)</code></th>
<td class="colLast">
<div class="block">Creates a section that contains no content used to allow <a href="CodeInterceptor.html" title="interface in software.amazon.smithy.utils"><code>CodeInterceptor</code></a>s
 to inject content at specific locations.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insertTrailingNewline()">insertTrailingNewline</a></span>()</code></th>
<td class="colLast">
<div class="block">Configures the AbstractCodeWriter to always append a newline at the end of
 the text if one is not already present.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insertTrailingNewline(boolean)">insertTrailingNewline</a></span>&#8203;(boolean&nbsp;trailingNewline)</code></th>
<td class="colLast">
<div class="block">Configures the AbstractCodeWriter to always append a newline at the end of
 the text if one is not already present.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isStackTraceRelevant(java.lang.StackTraceElement)">isStackTraceRelevant</a></span>&#8203;(java.lang.StackTraceElement&nbsp;e)</code></th>
<td class="colLast">
<div class="block">Tests if the given <code>StackTraceElement</code> is relevant for a comment
 used when writing debug information before calls to write.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onSection(java.lang.String,java.util.function.Consumer)">onSection</a></span>&#8203;(java.lang.String&nbsp;sectionName,
         java.util.function.Consumer&lt;java.lang.Object&gt;&nbsp;interceptor)</code></th>
<td class="colLast">
<div class="block">Registers a function that intercepts the contents of a section and
 writes to the <code>AbstractCodeWriter</code> with the updated contents.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>&lt;S extends <a href="CodeSection.html" title="interface in software.amazon.smithy.utils">CodeSection</a>&gt;<br><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onSection(software.amazon.smithy.utils.CodeInterceptor)">onSection</a></span>&#8203;(<a href="CodeInterceptor.html" title="interface in software.amazon.smithy.utils">CodeInterceptor</a>&lt;S,&#8203;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&gt;&nbsp;interceptor)</code></th>
<td class="colLast">
<div class="block">Intercepts a section of code emitted for a strongly typed <a href="CodeSection.html" title="interface in software.amazon.smithy.utils"><code>CodeSection</code></a>.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#openBlock(java.lang.String,java.lang.Object...)">openBlock</a></span>&#8203;(java.lang.String&nbsp;textBeforeNewline,
         java.lang.Object...&nbsp;args)</code></th>
<td class="colLast">
<div class="block">Opens a block of syntax by writing text, a newline, then indenting.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#openBlock(java.lang.String,java.lang.String,java.lang.Object%5B%5D,java.lang.Runnable)">openBlock</a></span>&#8203;(java.lang.String&nbsp;textBeforeNewline,
         java.lang.String&nbsp;textAfterNewline,
         java.lang.Object[]&nbsp;args,
         java.lang.Runnable&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Opens a block of syntax by writing <code>textBeforeNewline</code>, a newline, then
 indenting, then executes the given <code>Runnable</code>, then closes the block of
 syntax by writing a newline, dedenting, then writing <code>textAfterNewline</code>.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#openBlock(java.lang.String,java.lang.String,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Runnable)">openBlock</a></span>&#8203;(java.lang.String&nbsp;textBeforeNewline,
         java.lang.String&nbsp;textAfterNewline,
         java.lang.Object&nbsp;arg1,
         java.lang.Object&nbsp;arg2,
         java.lang.Object&nbsp;arg3,
         java.lang.Object&nbsp;arg4,
         java.lang.Object&nbsp;arg5,
         java.lang.Runnable&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Opens a block of syntax by writing <code>textBeforeNewline</code>, a newline, then
 indenting, then executes the given <code>Runnable</code>, then closes the block of
 syntax by writing a newline, dedenting, then writing <code>textAfterNewline</code>.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#openBlock(java.lang.String,java.lang.String,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Runnable)">openBlock</a></span>&#8203;(java.lang.String&nbsp;textBeforeNewline,
         java.lang.String&nbsp;textAfterNewline,
         java.lang.Object&nbsp;arg1,
         java.lang.Object&nbsp;arg2,
         java.lang.Object&nbsp;arg3,
         java.lang.Object&nbsp;arg4,
         java.lang.Runnable&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Opens a block of syntax by writing <code>textBeforeNewline</code>, a newline, then
 indenting, then executes the given <code>Runnable</code>, then closes the block of
 syntax by writing a newline, dedenting, then writing <code>textAfterNewline</code>.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#openBlock(java.lang.String,java.lang.String,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Runnable)">openBlock</a></span>&#8203;(java.lang.String&nbsp;textBeforeNewline,
         java.lang.String&nbsp;textAfterNewline,
         java.lang.Object&nbsp;arg1,
         java.lang.Object&nbsp;arg2,
         java.lang.Object&nbsp;arg3,
         java.lang.Runnable&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Opens a block of syntax by writing <code>textBeforeNewline</code>, a newline, then
 indenting, then executes the given <code>Runnable</code>, then closes the block of
 syntax by writing a newline, dedenting, then writing <code>textAfterNewline</code>.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#openBlock(java.lang.String,java.lang.String,java.lang.Object,java.lang.Object,java.lang.Runnable)">openBlock</a></span>&#8203;(java.lang.String&nbsp;textBeforeNewline,
         java.lang.String&nbsp;textAfterNewline,
         java.lang.Object&nbsp;arg1,
         java.lang.Object&nbsp;arg2,
         java.lang.Runnable&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Opens a block of syntax by writing <code>textBeforeNewline</code>, a newline, then
 indenting, then executes the given <code>Runnable</code>, then closes the block of
 syntax by writing a newline, dedenting, then writing <code>textAfterNewline</code>.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#openBlock(java.lang.String,java.lang.String,java.lang.Object,java.lang.Runnable)">openBlock</a></span>&#8203;(java.lang.String&nbsp;textBeforeNewline,
         java.lang.String&nbsp;textAfterNewline,
         java.lang.Object&nbsp;arg1,
         java.lang.Runnable&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Opens a block of syntax by writing <code>textBeforeNewline</code>, a newline, then
 indenting, then executes the given <code>Runnable</code>, then closes the block of
 syntax by writing a newline, dedenting, then writing <code>textAfterNewline</code>.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#openBlock(java.lang.String,java.lang.String,java.lang.Runnable)">openBlock</a></span>&#8203;(java.lang.String&nbsp;textBeforeNewline,
         java.lang.String&nbsp;textAfterNewline,
         java.lang.Runnable&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Opens a block of syntax by writing <code>textBeforeNewline</code>, a newline, then
 indenting, then executes the given <code>Runnable</code>, then closes the block of
 syntax by writing a newline, dedenting, then writing <code>textAfterNewline</code>.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#popState()">popState</a></span>()</code></th>
<td class="colLast">
<div class="block">Pops the current AbstractCodeWriter state from the state stack.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pushFilteredState(java.util.function.Function)">pushFilteredState</a></span>&#8203;(java.util.function.Function&lt;java.lang.String,&#8203;java.lang.String&gt;&nbsp;filter)</code></th>
<td class="colLast">
<div class="block">Pushes an anonymous named state that is always passed through the given
 filter function before being written to the writer.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pushState()">pushState</a></span>()</code></th>
<td class="colLast">
<div class="block">Copies and pushes the current state to the state stack.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pushState(java.lang.String)">pushState</a></span>&#8203;(java.lang.String&nbsp;sectionName)</code></th>
<td class="colLast">
<div class="block">Copies and pushes the current state to the state stack using a named
 state that can be intercepted by functions registered with
 <a href="#onSection(software.amazon.smithy.utils.CodeInterceptor)"><code>onSection(CodeInterceptor)</code></a>.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pushState(software.amazon.smithy.utils.CodeSection)">pushState</a></span>&#8203;(<a href="CodeSection.html" title="interface in software.amazon.smithy.utils">CodeSection</a>&nbsp;section)</code></th>
<td class="colLast">
<div class="block">Pushes a strongly typed section extension point.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#putContext(java.lang.String,java.lang.Object)">putContext</a></span>&#8203;(java.lang.String&nbsp;key,
          java.lang.Object&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Adds a named key-value pair to the context of the current state.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#putContext(java.util.Map)">putContext</a></span>&#8203;(java.util.Map&lt;java.lang.String,&#8203;java.lang.Object&gt;&nbsp;mappings)</code></th>
<td class="colLast">
<div class="block">Adds a map of named key-value pair to the context of the current state.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#putFormatter(char,java.util.function.BiFunction)">putFormatter</a></span>&#8203;(char&nbsp;identifier,
            java.util.function.BiFunction&lt;java.lang.Object,&#8203;java.lang.String,&#8203;java.lang.String&gt;&nbsp;formatFunction)</code></th>
<td class="colLast">
<div class="block">Adds a custom formatter expression to the current state of the
 <code>AbstractCodeWriter</code>.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeContext(java.lang.String)">removeContext</a></span>&#8203;(java.lang.String&nbsp;key)</code></th>
<td class="colLast">
<div class="block">Removes a named key-value pair from the context of the current state.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setExpressionStart(char)">setExpressionStart</a></span>&#8203;(char&nbsp;expressionStart)</code></th>
<td class="colLast">
<div class="block">Sets the character used to start expressions in the current state when calling
 <a href="#write(java.lang.Object,java.lang.Object...)"><code>write(java.lang.Object, java.lang.Object...)</code></a>, <a href="#writeInline(java.lang.Object,java.lang.Object...)"><code>writeInline(java.lang.Object, java.lang.Object...)</code></a>, <a href="#openBlock(java.lang.String,java.lang.Object...)"><code>openBlock(java.lang.String, java.lang.Object...)</code></a>, etc.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setIndentText(java.lang.String)">setIndentText</a></span>&#8203;(java.lang.String&nbsp;indentText)</code></th>
<td class="colLast">
<div class="block">Sets the text used for indentation (defaults to four spaces).</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNewline(char)">setNewline</a></span>&#8203;(char&nbsp;newline)</code></th>
<td class="colLast">
<div class="block">Sets the character used to represent newlines in the current state
 ("\n" is the default).</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNewline(java.lang.String)">setNewline</a></span>&#8203;(java.lang.String&nbsp;newline)</code></th>
<td class="colLast">
<div class="block">Sets the character used to represent newlines in the current state
 ("\n" is the default).</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNewlinePrefix(java.lang.String)">setNewlinePrefix</a></span>&#8203;(java.lang.String&nbsp;newlinePrefix)</code></th>
<td class="colLast">
<div class="block">Sets a prefix to prepend to every line after a new line is added
 (except for an inserted trailing newline).</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th>
<td class="colLast">
<div class="block">Gets the contents of the generated code.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#trimBlankLines()">trimBlankLines</a></span>()</code></th>
<td class="colLast">
<div class="block">Ensures that no more than one blank line occurs in succession.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#trimBlankLines(int)">trimBlankLines</a></span>&#8203;(int&nbsp;trimBlankLines)</code></th>
<td class="colLast">
<div class="block">Ensures that no more than the given number of newlines can occur
 in succession, removing consecutive newlines that exceed the given
 threshold.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#trimTrailingSpaces()">trimTrailingSpaces</a></span>()</code></th>
<td class="colLast">
<div class="block">Enables the trimming of trailing spaces on a line.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#trimTrailingSpaces(boolean)">trimTrailingSpaces</a></span>&#8203;(boolean&nbsp;trimTrailingSpaces)</code></th>
<td class="colLast">
<div class="block">Configures if trailing spaces on a line are removed.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unwrite(java.lang.Object,java.lang.Object...)">unwrite</a></span>&#8203;(java.lang.Object&nbsp;content,
       java.lang.Object...&nbsp;args)</code></th>
<td class="colLast">
<div class="block">Remove the most recent text written to the AbstractCodeWriter if and only
 if the last written text is exactly equal to the given expanded
 content string.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#write(java.lang.Object,java.lang.Object...)">write</a></span>&#8203;(java.lang.Object&nbsp;content,
     java.lang.Object...&nbsp;args)</code></th>
<td class="colLast">
<div class="block">Writes text to the AbstractCodeWriter and appends a newline.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#writeInline(java.lang.Object,java.lang.Object...)">writeInline</a></span>&#8203;(java.lang.Object&nbsp;content,
           java.lang.Object...&nbsp;args)</code></th>
<td class="colLast">
<div class="block">Writes text to the AbstractCodeWriter without appending a newline.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#writeInlineWithNoFormatting(java.lang.Object)">writeInlineWithNoFormatting</a></span>&#8203;(java.lang.Object&nbsp;content)</code></th>
<td class="colLast">
<div class="block">Writes inline text to the AbstractCodeWriter with no formatting.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#writeOptional(java.lang.Object)">writeOptional</a></span>&#8203;(java.lang.Object&nbsp;content)</code></th>
<td class="colLast">
<div class="block">Optionally writes text to the AbstractCodeWriter and appends a newline
 if a value is present.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code><a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#writeWithNoFormatting(java.lang.Object)">writeWithNoFormatting</a></span>&#8203;(java.lang.Object&nbsp;content)</code></th>
<td class="colLast">
<div class="block">Writes text to the AbstractCodeWriter and appends a newline.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>AbstractCodeWriter</h4>
<pre>public&nbsp;AbstractCodeWriter()</pre>
<div class="block">Creates a new SimpleCodeWriter that uses "\n" for a newline, four spaces
 for indentation, does not strip trailing whitespace, does not flatten
 multiple successive blank lines into a single blank line, and adds no
 trailing new line.</div>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="copySettingsFrom(software.amazon.smithy.utils.AbstractCodeWriter)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copySettingsFrom</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;copySettingsFrom&#8203;(<a href="AbstractCodeWriter.html" title="class in software.amazon.smithy.utils">AbstractCodeWriter</a>&lt;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&gt;&nbsp;other)</pre>
<div class="block">Copies settings from the given AbstractCodeWriter into this AbstractCodeWriter.

 <p>The settings of the <code>other</code> AbstractCodeWriter will overwrite both global and state-based settings
 of this AbstractCodeWriter.

 <p>Stateful settings of the <code>other</code> AbstractCodeWriter like formatters, interceptors, and context are
 flattened and then copied into the <em>current</em> state of this AbstractCodeWriter. Any conflicts between
 formatters, interceptors, or context of the current writer are overwritten by the other writer. The stack of
 states and the contents written to <code>other</code> are not copied.

 <pre><code>
 SimpleCodeWriter a = new SimpleCodeWriter();
 a.setExpressionStart('#');

 SimpleCodeWriter b = new SimpleCodeWriter();
 b.copySettingsFrom(a);

 assert(b.getExpressionStart() == '#');
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - CodeWriter to copy settings from.</dd>
</dl>
</li>
</ul>
<a id="formatLiteral(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>formatLiteral</h4>
<pre class="methodSignature">public static&nbsp;java.lang.String&nbsp;formatLiteral&#8203;(java.lang.Object&nbsp;value)</pre>
<div class="block">Provides the default functionality for formatting literal values.

 <p>This formatter is registered by default as the literal "L" formatter,
 and is called in the default string "S" formatter before escaping any
 characters in the string.

 <ul>
     <li><code>null</code>: Formatted as an empty string.</li>
     <li>Empty <code>Optional</code>: Formatted as an empty string.</li>
     <li><code>Optional</code> with value: Formatted as the formatted value in the optional.</li>
     <li>Everything else: Formatted as the result of <code>String.valueOf(java.lang.Object)</code>.</li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - Value to format.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the formatted value.</dd>
</dl>
</li>
</ul>
<a id="putFormatter(char,java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>putFormatter</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;putFormatter&#8203;(char&nbsp;identifier,
                      java.util.function.BiFunction&lt;java.lang.Object,&#8203;java.lang.String,&#8203;java.lang.String&gt;&nbsp;formatFunction)</pre>
<div class="block">Adds a custom formatter expression to the current state of the
 <code>AbstractCodeWriter</code>.

 <p>The provided <code>identifier</code> string must match the following ABNF:

 <pre>
 %x21-23    ; ( '!' - '#' )
 / %x25-2F  ; ( '%' - '/' )
 / %x3A-60  ; ( ':' - '`' )
 / %x7B-7E  ; ( '{' - '~' )
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>identifier</code> - Formatter identifier to associate with this formatter.</dd>
<dd><code>formatFunction</code> - Formatter function that formats the given object as a String.
                       The formatter is give the value to format as an object
                       (use .toString to access the string contents) and the
                       current indentation string of the AbstractCodeWriter.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="setExpressionStart(char)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setExpressionStart</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;setExpressionStart&#8203;(char&nbsp;expressionStart)</pre>
<div class="block">Sets the character used to start expressions in the current state when calling
 <a href="#write(java.lang.Object,java.lang.Object...)"><code>write(java.lang.Object, java.lang.Object...)</code></a>, <a href="#writeInline(java.lang.Object,java.lang.Object...)"><code>writeInline(java.lang.Object, java.lang.Object...)</code></a>, <a href="#openBlock(java.lang.String,java.lang.Object...)"><code>openBlock(java.lang.String, java.lang.Object...)</code></a>, etc.

 <p>By default, <code>$</code> is used to start expressions (for example
 <code>$L</code>. However, some programming languages frequently give
 syntactic meaning to <code>$</code>, making this an inconvenient syntactic
 character for the AbstractCodeWriter. In these cases, the character used to
 start a AbstractCodeWriter expression can be changed. Just like <code>$</code>, the
 custom start character can be escaped using two subsequent start
 characters (e.g., <code>$$</code>).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>expressionStart</code> - Character to use to start expressions.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="getExpressionStart()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExpressionStart</h4>
<pre class="methodSignature">public&nbsp;char&nbsp;getExpressionStart()</pre>
<div class="block">Get the expression start character of the <em>current</em> state.

 <p>This value should not be cached and reused across pushed and popped
 states. This value is "$" by default, but it can be changed using
 <a href="#setExpressionStart(char)"><code>setExpressionStart(char)</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the expression start char of the current state.</dd>
</dl>
</li>
</ul>
<a id="toString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;toString()</pre>
<div class="block">Gets the contents of the generated code.

 <p>The result will have an appended newline if the AbstractCodeWriter is
 configured to always append a newline. A newline is only appended
 in these cases if the result does not already end with a newline.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the generated code.</dd>
</dl>
</li>
</ul>
<a id="pushState()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pushState</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;pushState()</pre>
<div class="block">Copies and pushes the current state to the state stack.

 <p>This method is used to prepare for a corresponding <a href="#popState()"><code>popState()</code></a>
 operation later. It stores the current state of the AbstractCodeWriter into a
 stack and keeps it active. After pushing, mutations can be made to the
 state of the AbstractCodeWriter without affecting the previous state on the
 stack. Changes to the state of the AbstractCodeWriter can be undone by using
 <a href="#popState()"><code>popState()</code></a>, which Returns self state to the state
 it was in before calling <code>pushState</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the code writer.</dd>
</dl>
</li>
</ul>
<a id="pushState(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pushState</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;pushState&#8203;(java.lang.String&nbsp;sectionName)</pre>
<div class="block">Copies and pushes the current state to the state stack using a named
 state that can be intercepted by functions registered with
 <a href="#onSection(software.amazon.smithy.utils.CodeInterceptor)"><code>onSection(CodeInterceptor)</code></a>.

 <p>The text written while in this state is buffered and passed to each
 state interceptor. If no text is written by the section or an
 interceptor, nothing is changed on the <code>AbstractCodeWriter</code>. This
 behavior allows for placeholder sections to be added into
 <code>AbstractCodeWriter</code> generators in order to provide extension points
 that can be otherwise empty.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sectionName</code> - Name of the section to set on the state.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the code writer.</dd>
</dl>
</li>
</ul>
<a id="pushState(software.amazon.smithy.utils.CodeSection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pushState</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;pushState&#8203;(<a href="CodeSection.html" title="interface in software.amazon.smithy.utils">CodeSection</a>&nbsp;section)</pre>
<div class="block">Pushes a strongly typed section extension point.

 <p>Interceptors can be registered to intercept this specific type
 of CodeSection using a <a href="CodeInterceptor.html" title="interface in software.amazon.smithy.utils"><code>CodeInterceptor</code></a> and providing a
 class for which <code>section</code> is an instance.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>section</code> - The section value to push.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#onSection(software.amazon.smithy.utils.CodeInterceptor)"><code>onSection(CodeInterceptor)</code></a></dd>
</dl>
</li>
</ul>
<a id="injectSection(software.amazon.smithy.utils.CodeSection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>injectSection</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;injectSection&#8203;(<a href="CodeSection.html" title="interface in software.amazon.smithy.utils">CodeSection</a>&nbsp;section)</pre>
<div class="block">Creates a section that contains no content used to allow <a href="CodeInterceptor.html" title="interface in software.amazon.smithy.utils"><code>CodeInterceptor</code></a>s
 to inject content at specific locations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>section</code> - The code section to register that can be intercepted by type.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="getDebugInfo()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDebugInfo</h4>
<pre class="methodSignature">public final&nbsp;<a href="CodeWriterDebugInfo.html" title="class in software.amazon.smithy.utils">CodeWriterDebugInfo</a>&nbsp;getDebugInfo()</pre>
<div class="block">Gets debug information about the current state of the AbstractCodeWriter, including
 the path to the current state as returned by <code>getStateDebugPath()</code>,
 and up to the last two lines of text written to the AbstractCodeWriter.

 <p>This debug information is used in most exceptions thrown by AbstractCodeWriter to
 provide additional context when something goes wrong. It can also be used
 by subclasses and collaborators to aid in debugging codegen issues.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns debug info as a string.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#getDebugInfo(int)"><code>getDebugInfo(int)</code></a></dd>
</dl>
</li>
</ul>
<a id="getDebugInfo(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDebugInfo</h4>
<pre class="methodSignature">public&nbsp;<a href="CodeWriterDebugInfo.html" title="class in software.amazon.smithy.utils">CodeWriterDebugInfo</a>&nbsp;getDebugInfo&#8203;(int&nbsp;numberOfContextLines)</pre>
<div class="block">Gets debug information about the current state of the AbstractCodeWriter.

 <p>This method can be overridden in order to add more metadata to the created
 debug info object.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>numberOfContextLines</code> - Include the last N lines in the output. Set to 0 to omit lines.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns debug info as a string.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#getDebugInfo()"><code>getDebugInfo()</code></a></dd>
</dl>
</li>
</ul>
<a id="pushFilteredState(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pushFilteredState</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;pushFilteredState&#8203;(java.util.function.Function&lt;java.lang.String,&#8203;java.lang.String&gt;&nbsp;filter)</pre>
<div class="block">Pushes an anonymous named state that is always passed through the given
 filter function before being written to the writer.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filter</code> - Function that maps over the entire section when popped.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the code writer.</dd>
</dl>
</li>
</ul>
<a id="popState()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>popState</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;popState()</pre>
<div class="block">Pops the current AbstractCodeWriter state from the state stack.

 <p>This method is used to reverse a previous <a href="#pushState()"><code>pushState()</code></a>
 operation. It configures the current AbstractCodeWriter state to what it was
 before the last preceding <code>pushState</code> call.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - if there a no states to pop.</dd>
</dl>
</li>
</ul>
<a id="onSection(java.lang.String,java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onSection</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;onSection&#8203;(java.lang.String&nbsp;sectionName,
                   java.util.function.Consumer&lt;java.lang.Object&gt;&nbsp;interceptor)</pre>
<div class="block">Registers a function that intercepts the contents of a section and
 writes to the <code>AbstractCodeWriter</code> with the updated contents.

 <p>The <code>interceptor</code> function is expected to have a reference to
 the <code>AbstractCodeWriter</code> and to mutate it when they are invoked. Each
 interceptor is invoked in their own isolated pushed/popped states.

 <p>The text provided to <code>interceptor</code> does not contain a trailing
 new line. A trailing new line is expected to be injected automatically
 when the results of intercepting the contents are written to the
 <code>AbstractCodeWriter</code>. A result is only written if the interceptors write
 a non-null, non-empty string, allowing for empty placeholders to be
 added that don't affect the resulting layout of the code.

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();

 // Prepend text to a section named "foo".
 writer.onSectionPrepend("foo", () -&gt; writer.write("A"));

 // Write text to a section, and ensure that the original
 // text is written too.
 writer.onSection("foo", text -&gt; {
     // Write before the original text.
     writer.write("A");
     // Write the original text of the section.
     writer.writeWithNoFormatting(text);
     // Write more text to the section.
     writer.write("C");
 });

 // Create the section, write to it, then close the section.
 writer.pushState("foo").write("B").popState();

 assert(writer.toString().equals("A\nB\nC\n"));
 </code></pre>

 <h3>Newline handling</h3>

 <p>This method is a wrapper around <a href="#onSection(software.amazon.smithy.utils.CodeInterceptor)"><code>onSection(CodeInterceptor)</code></a>
 that has several limitations:

 <ul>
     <li>The provided <code>interceptor</code> is expected to have a reference
     to an <a href="AbstractCodeWriter.html" title="class in software.amazon.smithy.utils"><code>AbstractCodeWriter</code></a> so that write calls can be made.</li>
     <li>The handling of newlines is much less precise. If you want to
     give interceptors full control over how newlines are injected, then
     <a href="#onSection(software.amazon.smithy.utils.CodeInterceptor)"><code>onSection(CodeInterceptor)</code></a> must be used directly and
     careful use of <a href="#writeInlineWithNoFormatting(java.lang.Object)"><code>writeInlineWithNoFormatting(Object)</code></a> is
     required when writing the previous contents to the interceptor.</li>
     <li>Interceptors do not have access to strongly typed event data
     like <a href="CodeInterceptor.html" title="interface in software.amazon.smithy.utils"><code>CodeInterceptor</code></a>s do.
 </ul>

 <p>The newline handling functionality provided by this method can be
 reproduced using a <a href="CodeInterceptor.html" title="interface in software.amazon.smithy.utils"><code>CodeInterceptor</code></a> by removing trailing newlines
 using <code>removeTrailingNewline(String)</code>.

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();

 CodeInterceptor&lt;CodeSection, SimpleCodeWriter&gt; interceptor = CodeInterceptor.forName(sectionName, (w, p) -&gt; {
     String trimmedContent = removeTrailingNewline(p);
     interceptor.accept(trimmedContent);
 })

 writer.onSection(interceptor);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sectionName</code> - The name of the section to intercept.</dd>
<dd><code>interceptor</code> - The function to intercept with.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="onSection(software.amazon.smithy.utils.CodeInterceptor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onSection</h4>
<pre class="methodSignature">public&nbsp;&lt;S extends <a href="CodeSection.html" title="interface in software.amazon.smithy.utils">CodeSection</a>&gt;&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;onSection&#8203;(<a href="CodeInterceptor.html" title="interface in software.amazon.smithy.utils">CodeInterceptor</a>&lt;S,&#8203;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&gt;&nbsp;interceptor)</pre>
<div class="block">Intercepts a section of code emitted for a strongly typed <a href="CodeSection.html" title="interface in software.amazon.smithy.utils"><code>CodeSection</code></a>.

 <p>These section interceptors provide a kind of event-based hook system for
 AbstractCodeWriters that add extension points when generating code. The function has
 the ability to completely ignore the original contents of the section, to
 prepend text to it, and append text to it. Intercepting functions are
 expected to have a reference to the <code>AbstractCodeWriter</code> and to mutate it
 when they are invoked. Each interceptor is invoked in their own
 isolated pushed/popped states.

 <p>Interceptors are registered on the current state of the
 <code>AbstractCodeWriter</code>. When the state to which an interceptor is registered
 is popped, the interceptor is no longer in scope.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>S</code> - The type of section being intercepted.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>interceptor</code> - A consumer that takes the writer and strongly typed section.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="disableNewlines()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>disableNewlines</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;disableNewlines()</pre>
<div class="block">Disables the automatic appending of newlines in the current state.

 <p>Methods like <a href="#write(java.lang.Object,java.lang.Object...)"><code>write(java.lang.Object, java.lang.Object...)</code></a>, <a href="#openBlock(java.lang.String,java.lang.Object...)"><code>openBlock(java.lang.String, java.lang.Object...)</code></a>, and <a href="#closeBlock(java.lang.String,java.lang.Object...)"><code>closeBlock(java.lang.String, java.lang.Object...)</code></a>
 will not automatically append newlines when a state has this flag set.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="enableNewlines()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enableNewlines</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;enableNewlines()</pre>
<div class="block">Enables the automatic appending of newlines in the current state.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="setNewline(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNewline</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;setNewline&#8203;(java.lang.String&nbsp;newline)</pre>
<div class="block">Sets the character used to represent newlines in the current state
 ("\n" is the default).

 <p>When the provided string is empty (""), then newlines are disabled
 in the current state. This is exactly equivalent to calling
 <a href="#disableNewlines()"><code>disableNewlines()</code></a>, and does not actually change the newline
 character of the current state.

 <p>Setting the newline character to a non-empty string implicitly
 enables newlines in the current state.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>newline</code> - Newline character to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="setNewline(char)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNewline</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;setNewline&#8203;(char&nbsp;newline)</pre>
<div class="block">Sets the character used to represent newlines in the current state
 ("\n" is the default).

 <p>This call also enables newlines in the current state by calling
 <a href="#enableNewlines()"><code>enableNewlines()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>newline</code> - Newline character to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="getNewline()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNewline</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;getNewline()</pre>
<div class="block">Gets the character used to represent newlines in the current state.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the newline string.</dd>
</dl>
</li>
</ul>
<a id="setIndentText(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setIndentText</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;setIndentText&#8203;(java.lang.String&nbsp;indentText)</pre>
<div class="block">Sets the text used for indentation (defaults to four spaces).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>indentText</code> - Indentation text.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="getIndentText()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIndentText</h4>
<pre class="methodSignature">public final&nbsp;java.lang.String&nbsp;getIndentText()</pre>
<div class="block">Gets the text used for indentation (defaults to four spaces).</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the indentation string.</dd>
</dl>
</li>
</ul>
<a id="trimTrailingSpaces()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>trimTrailingSpaces</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;trimTrailingSpaces()</pre>
<div class="block">Enables the trimming of trailing spaces on a line.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="trimTrailingSpaces(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>trimTrailingSpaces</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;trimTrailingSpaces&#8203;(boolean&nbsp;trimTrailingSpaces)</pre>
<div class="block">Configures if trailing spaces on a line are removed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>trimTrailingSpaces</code> - Set to true to trim trailing spaces.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="getTrimTrailingSpaces()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTrimTrailingSpaces</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getTrimTrailingSpaces()</pre>
<div class="block">Returns true if the trailing spaces in the current state are trimmed.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the trailing spaces setting of the current state.</dd>
</dl>
</li>
</ul>
<a id="trimBlankLines()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>trimBlankLines</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;trimBlankLines()</pre>
<div class="block">Ensures that no more than one blank line occurs in succession.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="trimBlankLines(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>trimBlankLines</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;trimBlankLines&#8203;(int&nbsp;trimBlankLines)</pre>
<div class="block">Ensures that no more than the given number of newlines can occur
 in succession, removing consecutive newlines that exceed the given
 threshold.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>trimBlankLines</code> - Number of allowed consecutive newlines. Set to
  -1 to perform no trimming. Set to 0 to allow no blank lines. Set to
  1 or more to allow for no more than N consecutive blank lines.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="getTrimBlankLines()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTrimBlankLines</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getTrimBlankLines()</pre>
<div class="block">Returns the number of allowed consecutive newlines that are not
 trimmed by the AbstractCodeWriter when written to a string.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the number of allowed consecutive newlines. -1 means
   that no newlines are trimmed. 0 allows no blank lines. 1 or more
   allows for no more than N consecutive blank lines.</dd>
</dl>
</li>
</ul>
<a id="insertTrailingNewline()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>insertTrailingNewline</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;insertTrailingNewline()</pre>
<div class="block">Configures the AbstractCodeWriter to always append a newline at the end of
 the text if one is not already present.

 <p>This setting is not captured as part of push/popState.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="insertTrailingNewline(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>insertTrailingNewline</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;insertTrailingNewline&#8203;(boolean&nbsp;trailingNewline)</pre>
<div class="block">Configures the AbstractCodeWriter to always append a newline at the end of
 the text if one is not already present.

 <p>This setting is not captured as part of push/popState.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>trailingNewline</code> - True if a newline is added.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="getInsertTrailingNewline()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInsertTrailingNewline</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getInsertTrailingNewline()</pre>
<div class="block">Checks if the AbstractCodeWriter inserts a trailing newline (if necessary) when
 converted to a string.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The newline behavior (true to insert a trailing newline).</dd>
</dl>
</li>
</ul>
<a id="setNewlinePrefix(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNewlinePrefix</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;setNewlinePrefix&#8203;(java.lang.String&nbsp;newlinePrefix)</pre>
<div class="block">Sets a prefix to prepend to every line after a new line is added
 (except for an inserted trailing newline).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>newlinePrefix</code> - Newline prefix to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="getNewlinePrefix()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNewlinePrefix</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;getNewlinePrefix()</pre>
<div class="block">Gets the prefix to prepend to every line after a new line is added
 (except for an inserted trailing newline).</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the newline prefix string.</dd>
</dl>
</li>
</ul>
<a id="indent()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indent</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;indent()</pre>
<div class="block">Indents all text one level.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="indent(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indent</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;indent&#8203;(int&nbsp;levels)</pre>
<div class="block">Indents all text a specific number of levels.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>levels</code> - Number of levels to indent.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="getIndentLevel()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIndentLevel</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getIndentLevel()</pre>
<div class="block">Gets the indentation level of the current state.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the indentation level of the current state.</dd>
</dl>
</li>
</ul>
<a id="dedent()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dedent</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;dedent()</pre>
<div class="block">Removes one level of indentation from all lines.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="dedent(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dedent</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;dedent&#8203;(int&nbsp;levels)</pre>
<div class="block">Removes a specific number of indentations from all lines.

 <p>Set to -1 to dedent back to 0 (root).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>levels</code> - Number of levels to remove.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - when trying to dedent too far.</dd>
</dl>
</li>
</ul>
<a id="openBlock(java.lang.String,java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openBlock</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;openBlock&#8203;(java.lang.String&nbsp;textBeforeNewline,
                   java.lang.Object...&nbsp;args)</pre>
<div class="block">Opens a block of syntax by writing text, a newline, then indenting.

 <pre>
 <code>
 String result = new SimpleCodeWriter()
         .openBlock("public final class $L {", "Foo")
             .openBlock("public void main(String[] args) {")
                 .write("System.out.println(args[0]);")
             .closeBlock("}")
         .closeBlock("}")
         .toString();
 </code>
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>textBeforeNewline</code> - Text to write before writing a newline and indenting.</dd>
<dd><code>args</code> - String arguments to use for formatting.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns this.</dd>
</dl>
</li>
</ul>
<a id="openBlock(java.lang.String,java.lang.String,java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openBlock</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;openBlock&#8203;(java.lang.String&nbsp;textBeforeNewline,
                   java.lang.String&nbsp;textAfterNewline,
                   java.lang.Runnable&nbsp;f)</pre>
<div class="block">Opens a block of syntax by writing <code>textBeforeNewline</code>, a newline, then
 indenting, then executes the given <code>Runnable</code>, then closes the block of
 syntax by writing a newline, dedenting, then writing <code>textAfterNewline</code>.

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 writer.openBlock("public final class $L {", "}", "Foo", () -&gt; {
     writer.openBlock("public void main(String[] args) {", "}", () -&gt; {
         writer.write("System.out.println(args[0]);");
     })
 });
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>textBeforeNewline</code> - Text to write before writing a newline and indenting.</dd>
<dd><code>textAfterNewline</code> - Text to write after writing a newline and indenting.</dd>
<dd><code>f</code> - Runnable function to execute inside of the block.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns this.</dd>
</dl>
</li>
</ul>
<a id="openBlock(java.lang.String,java.lang.String,java.lang.Object,java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openBlock</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;openBlock&#8203;(java.lang.String&nbsp;textBeforeNewline,
                   java.lang.String&nbsp;textAfterNewline,
                   java.lang.Object&nbsp;arg1,
                   java.lang.Runnable&nbsp;f)</pre>
<div class="block">Opens a block of syntax by writing <code>textBeforeNewline</code>, a newline, then
 indenting, then executes the given <code>Runnable</code>, then closes the block of
 syntax by writing a newline, dedenting, then writing <code>textAfterNewline</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>textBeforeNewline</code> - Text to write before writing a newline and indenting.</dd>
<dd><code>textAfterNewline</code> - Text to write after writing a newline and indenting.</dd>
<dd><code>arg1</code> - First positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>f</code> - Runnable function to execute inside of the block.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns this.</dd>
</dl>
</li>
</ul>
<a id="openBlock(java.lang.String,java.lang.String,java.lang.Object,java.lang.Object,java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openBlock</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;openBlock&#8203;(java.lang.String&nbsp;textBeforeNewline,
                   java.lang.String&nbsp;textAfterNewline,
                   java.lang.Object&nbsp;arg1,
                   java.lang.Object&nbsp;arg2,
                   java.lang.Runnable&nbsp;f)</pre>
<div class="block">Opens a block of syntax by writing <code>textBeforeNewline</code>, a newline, then
 indenting, then executes the given <code>Runnable</code>, then closes the block of
 syntax by writing a newline, dedenting, then writing <code>textAfterNewline</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>textBeforeNewline</code> - Text to write before writing a newline and indenting.</dd>
<dd><code>textAfterNewline</code> - Text to write after writing a newline and indenting.</dd>
<dd><code>arg1</code> - First positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>arg2</code> - Second positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>f</code> - Runnable function to execute inside of the block.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns this.</dd>
</dl>
</li>
</ul>
<a id="openBlock(java.lang.String,java.lang.String,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openBlock</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;openBlock&#8203;(java.lang.String&nbsp;textBeforeNewline,
                   java.lang.String&nbsp;textAfterNewline,
                   java.lang.Object&nbsp;arg1,
                   java.lang.Object&nbsp;arg2,
                   java.lang.Object&nbsp;arg3,
                   java.lang.Runnable&nbsp;f)</pre>
<div class="block">Opens a block of syntax by writing <code>textBeforeNewline</code>, a newline, then
 indenting, then executes the given <code>Runnable</code>, then closes the block of
 syntax by writing a newline, dedenting, then writing <code>textAfterNewline</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>textBeforeNewline</code> - Text to write before writing a newline and indenting.</dd>
<dd><code>textAfterNewline</code> - Text to write after writing a newline and indenting.</dd>
<dd><code>arg1</code> - First positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>arg2</code> - Second positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>arg3</code> - Third positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>f</code> - Runnable function to execute inside of the block.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns this.</dd>
</dl>
</li>
</ul>
<a id="openBlock(java.lang.String,java.lang.String,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openBlock</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;openBlock&#8203;(java.lang.String&nbsp;textBeforeNewline,
                   java.lang.String&nbsp;textAfterNewline,
                   java.lang.Object&nbsp;arg1,
                   java.lang.Object&nbsp;arg2,
                   java.lang.Object&nbsp;arg3,
                   java.lang.Object&nbsp;arg4,
                   java.lang.Runnable&nbsp;f)</pre>
<div class="block">Opens a block of syntax by writing <code>textBeforeNewline</code>, a newline, then
 indenting, then executes the given <code>Runnable</code>, then closes the block of
 syntax by writing a newline, dedenting, then writing <code>textAfterNewline</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>textBeforeNewline</code> - Text to write before writing a newline and indenting.</dd>
<dd><code>textAfterNewline</code> - Text to write after writing a newline and indenting.</dd>
<dd><code>arg1</code> - First positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>arg2</code> - Second positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>arg3</code> - Third positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>arg4</code> - Fourth positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>f</code> - Runnable function to execute inside of the block.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns this.</dd>
</dl>
</li>
</ul>
<a id="openBlock(java.lang.String,java.lang.String,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openBlock</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;openBlock&#8203;(java.lang.String&nbsp;textBeforeNewline,
                   java.lang.String&nbsp;textAfterNewline,
                   java.lang.Object&nbsp;arg1,
                   java.lang.Object&nbsp;arg2,
                   java.lang.Object&nbsp;arg3,
                   java.lang.Object&nbsp;arg4,
                   java.lang.Object&nbsp;arg5,
                   java.lang.Runnable&nbsp;f)</pre>
<div class="block">Opens a block of syntax by writing <code>textBeforeNewline</code>, a newline, then
 indenting, then executes the given <code>Runnable</code>, then closes the block of
 syntax by writing a newline, dedenting, then writing <code>textAfterNewline</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>textBeforeNewline</code> - Text to write before writing a newline and indenting.</dd>
<dd><code>textAfterNewline</code> - Text to write after writing a newline and indenting.</dd>
<dd><code>arg1</code> - First positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>arg2</code> - Second positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>arg3</code> - Third positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>arg4</code> - Fourth positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>arg5</code> - Fifth positional argument to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>f</code> - Runnable function to execute inside of the block.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns this.</dd>
</dl>
</li>
</ul>
<a id="openBlock(java.lang.String,java.lang.String,java.lang.Object[],java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openBlock</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;openBlock&#8203;(java.lang.String&nbsp;textBeforeNewline,
                   java.lang.String&nbsp;textAfterNewline,
                   java.lang.Object[]&nbsp;args,
                   java.lang.Runnable&nbsp;f)</pre>
<div class="block">Opens a block of syntax by writing <code>textBeforeNewline</code>, a newline, then
 indenting, then executes the given <code>Runnable</code>, then closes the block of
 syntax by writing a newline, dedenting, then writing <code>textAfterNewline</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>textBeforeNewline</code> - Text to write before writing a newline and indenting.</dd>
<dd><code>textAfterNewline</code> - Text to write after writing a newline and indenting.</dd>
<dd><code>args</code> - Arguments to substitute into <code>textBeforeNewline</code>.</dd>
<dd><code>f</code> - Runnable function to execute inside of the block.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns this.</dd>
</dl>
</li>
</ul>
<a id="closeBlock(java.lang.String,java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closeBlock</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;closeBlock&#8203;(java.lang.String&nbsp;textAfterNewline,
                    java.lang.Object...&nbsp;args)</pre>
<div class="block">Closes a block of syntax by writing a newline, dedenting, then writing text.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>textAfterNewline</code> - Text to write after writing a newline and dedenting.</dd>
<dd><code>args</code> - String arguments to use for formatting.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns this.</dd>
</dl>
</li>
</ul>
<a id="writeWithNoFormatting(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeWithNoFormatting</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;writeWithNoFormatting&#8203;(java.lang.Object&nbsp;content)</pre>
<div class="block">Writes text to the AbstractCodeWriter and appends a newline.

 <p>The provided text does not use any kind of expression formatting.

 <p>Indentation and the newline prefix is only prepended if the writer's
 cursor is at the beginning of a newline.

 <p>Stack trace comments are written along with the given content if
 <a href="#enableStackTraceComments(boolean)"><code>enableStackTraceComments(boolean)</code></a> was called with <code>true</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>content</code> - Content to write.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="isStackTraceRelevant(java.lang.StackTraceElement)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isStackTraceRelevant</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;isStackTraceRelevant&#8203;(java.lang.StackTraceElement&nbsp;e)</pre>
<div class="block">Tests if the given <code>StackTraceElement</code> is relevant for a comment
 used when writing debug information before calls to write.

 <p>The default implementation filters out all methods in "java.*",
 AbstractCodeWriter, software.amazon.smithy.utils.SymbolWriter,
 SimpleCodeWriter, and methods of the implementing subclass of
 AbstractCodeWriter. This method can be overridden to further filter
 stack frames as needed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>e</code> - StackTraceElement to test.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns true if this element should be in a comment.</dd>
</dl>
</li>
</ul>
<a id="formatWithStackTraceElement(java.lang.String,java.lang.StackTraceElement,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>formatWithStackTraceElement</h4>
<pre class="methodSignature">protected&nbsp;java.lang.String&nbsp;formatWithStackTraceElement&#8203;(java.lang.String&nbsp;content,
                                                       java.lang.StackTraceElement&nbsp;element,
                                                       boolean&nbsp;inline)</pre>
<div class="block">Formats content for the given stack frame.

 <p>Subclasses are expected to override this method as needed to handle
 language-specific comment requirements. By default, this class will use
 C/Java style "traditional" comments that come on the same line before
 both calls to writeInline and calls to write with a newline
 {@see https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.7}.

 <p>Programming languages that do not support inline comments should return
 the given <code>content</code> string as-is when <code>writingInline</code> is set
 to <code>true</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>content</code> - The content about to be written.</dd>
<dd><code>element</code> - The <code>StackFrameElement</code> to format.</dd>
<dd><code>inline</code> - Set to true when this is a comment intended to appear before inline content.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the formatted content that includes a leading comment.</dd>
</dl>
</li>
</ul>
<a id="writeInlineWithNoFormatting(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeInlineWithNoFormatting</h4>
<pre class="methodSignature">public final&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;writeInlineWithNoFormatting&#8203;(java.lang.Object&nbsp;content)</pre>
<div class="block">Writes inline text to the AbstractCodeWriter with no formatting.

 <p>The provided text does not use any kind of expression formatting.
 Indentation and the newline prefix is only prepended if the writer's
 cursor is at the beginning of a newline.

 <p>Stack trace comments are written along with the given content if
 <a href="#enableStackTraceComments(boolean)"><code>enableStackTraceComments(boolean)</code></a> was called with <code>true</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>content</code> - Inline content to write.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="format(java.lang.Object,java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>format</h4>
<pre class="methodSignature">public final&nbsp;java.lang.String&nbsp;format&#8203;(java.lang.Object&nbsp;content,
                                     java.lang.Object...&nbsp;args)</pre>
<div class="block">Creates a formatted string using formatter expressions and variadic
 arguments.

 <p>Important: if the formatters that are executed while formatting the
 given <code>content</code> string mutate the AbstractCodeWriter, it could leave the
 SimpleCodeWriter in an inconsistent state. For example, some AbstractCodeWriter
 implementations manage imports and dependencies automatically based on
 code that is referenced by formatters. If such an expression is used
 with this format method but the returned String is never written to the
 AbstractCodeWriter, then the AbstractCodeWriter might be mutated to track dependencies
 that aren't actually necessary.

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 String name = "Person";
 String formatted = writer.format("Hello, $L", name);
 assert(formatted.equals("Hello, Person"));
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>content</code> - Content to format.</dd>
<dd><code>args</code> - String arguments to use for formatting.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the formatted string.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#write(java.lang.Object,java.lang.Object...)"><code>write(java.lang.Object, java.lang.Object...)</code></a>, 
<a href="#putFormatter(char,java.util.function.BiFunction)"><code>putFormatter(char, java.util.function.BiFunction&lt;java.lang.Object, java.lang.String, java.lang.String&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a id="consumer(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>consumer</h4>
<pre class="methodSignature">public&nbsp;java.util.function.Consumer&lt;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&gt;&nbsp;consumer&#8203;(java.util.function.Consumer&lt;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&gt;&nbsp;consumer)</pre>
<div class="block">A simple helper method that makes it easier to invoke the built-in <code>C</code>
 (call) formatter using a <code>Consumer</code> where <code>T</code> is the specific type
 of <a href="AbstractCodeWriter.html" title="class in software.amazon.smithy.utils"><code>AbstractCodeWriter</code></a>.

 <p>Instead of having to type this:

 <pre><code>
 writer.write("$C", (Consumer&lt;MyWriter&gt;) (w) -&gt; w.write("Hi"));
 </code></pre>

 <p>You can write:

 <pre><code>
 writer.write("$C", writer.consumer(w -&gt; w.write("Hi"));
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>consumer</code> - The consumer to call.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the consumer as-is, but cast as the appropriate Java type.</dd>
</dl>
</li>
</ul>
<a id="call(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>call</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;call&#8203;(java.lang.Runnable&nbsp;task)</pre>
<div class="block">Allows calling out to arbitrary code for things like looping or
 conditional writes without breaking method chaining.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>task</code> - Method to invoke.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns this.</dd>
</dl>
</li>
</ul>
<a id="write(java.lang.Object,java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>write</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;write&#8203;(java.lang.Object&nbsp;content,
               java.lang.Object...&nbsp;args)</pre>
<div class="block">Writes text to the AbstractCodeWriter and appends a newline.

 <p>The provided text is automatically formatted using variadic
 arguments.

 <p>Indentation and the newline prefix is only prepended if the writer's
 cursor is at the beginning of a newline.

 <p>If a subclass overrides this method, it <em>should</em> first
 perform formatting and then delegate to <a href="#writeWithNoFormatting(java.lang.Object)"><code>writeWithNoFormatting(java.lang.Object)</code></a>
 to perform the actual write.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>content</code> - Content to write.</dd>
<dd><code>args</code> - String arguments to use for formatting.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="writeInline(java.lang.Object,java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeInline</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;writeInline&#8203;(java.lang.Object&nbsp;content,
                     java.lang.Object...&nbsp;args)</pre>
<div class="block">Writes text to the AbstractCodeWriter without appending a newline.

 <p>The provided text is automatically formatted using variadic
 arguments.

 <p>Indentation and the newline prefix is only prepended if the writer's
 cursor is at the beginning of a newline.

 <p>If newlines are present in the given string, each of those lines will receive proper indentation.

 <p>If a subclass overrides this method, it <em>should</em> first
 perform formatting and then delegate to <a href="#writeInlineWithNoFormatting(java.lang.Object)"><code>writeInlineWithNoFormatting(java.lang.Object)</code></a>
 to perform the actual write.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>content</code> - Content to write.</dd>
<dd><code>args</code> - String arguments to use for formatting.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="ensureNewline()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ensureNewline</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;ensureNewline()</pre>
<div class="block">Ensures that the last text written to the writer was a newline as defined in
 the current state and inserts one if necessary.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="writeOptional(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeOptional</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;writeOptional&#8203;(java.lang.Object&nbsp;content)</pre>
<div class="block">Optionally writes text to the AbstractCodeWriter and appends a newline
 if a value is present.

 <p>If the provided <code>content</code> value is <code>null</code>, nothing is
 written. If the provided <code>content</code> value is an empty
 <code>Optional</code>, nothing is written. If the result of calling
 <code>toString</code> on <code>content</code> results in an empty string,
 nothing is written. Finally, if the value is a non-empty string,
 the content is written to the <code>AbstractCodeWriter</code> at the current
 level of indentation, and a newline is appended.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>content</code> - Content to write if present.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="unwrite(java.lang.Object,java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unwrite</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;unwrite&#8203;(java.lang.Object&nbsp;content,
                 java.lang.Object...&nbsp;args)</pre>
<div class="block">Remove the most recent text written to the AbstractCodeWriter if and only
 if the last written text is exactly equal to the given expanded
 content string.

 <p>This can be useful, for example, for use cases like removing
 trailing commas from lists of values.

 <p>For example, the following will remove ", there." from the
 end of the AbstractCodeWriter:

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 writer.writeInline("Hello, there.");
 writer.unwrite(", there.");
 assert(writer.toString().equals("Hello\n"));
 </code></pre>

 <p>However, the following call to unwrite will do nothing because
 the last text written to the AbstractCodeWriter does not match:

 <pre><code>
 SimpleCodeWriter = new SimpleCodeWriter();
 writer.writeInline("Hello.");
 writer.unwrite("there.");
 assert(writer.toString().equals("Hello.\n"));
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>content</code> - Content to write.</dd>
<dd><code>args</code> - String arguments to use for formatting.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="putContext(java.lang.String,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>putContext</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;putContext&#8203;(java.lang.String&nbsp;key,
                    java.lang.Object&nbsp;value)</pre>
<div class="block">Adds a named key-value pair to the context of the current state.

 <p>These context values can be referenced by named interpolated
 parameters.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - Key to add to the context.</dd>
<dd><code>value</code> - Value to associate with the key.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="putContext(java.util.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>putContext</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;putContext&#8203;(java.util.Map&lt;java.lang.String,&#8203;java.lang.Object&gt;&nbsp;mappings)</pre>
<div class="block">Adds a map of named key-value pair to the context of the current state.

 <p>These context values can be referenced by named interpolated
 parameters.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mappings</code> - Key value pairs to add.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="removeContext(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeContext</h4>
<pre class="methodSignature">public&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;removeContext&#8203;(java.lang.String&nbsp;key)</pre>
<div class="block">Removes a named key-value pair from the context of the current state.

 <p>This method has no effect if the parent state defines the context key value pair.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - Key to add to remove from the current context.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
<a id="getContext(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getContext</h4>
<pre class="methodSignature">public&nbsp;java.lang.Object&nbsp;getContext&#8203;(java.lang.String&nbsp;key)</pre>
<div class="block">Gets a named contextual key-value pair from the current state or any parent states.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - Key to retrieve.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the associated value or null if not present.</dd>
</dl>
</li>
</ul>
<a id="getContext(java.lang.String,java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getContext</h4>
<pre class="methodSignature">public&nbsp;&lt;C&gt;&nbsp;C&nbsp;getContext&#8203;(java.lang.String&nbsp;key,
                        java.lang.Class&lt;C&gt;&nbsp;type)</pre>
<div class="block">Gets a named context key-value pair from the current state and
 casts the value to the given type.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - Key to retrieve.</dd>
<dd><code>type</code> - The type of value expected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the associated value or null if not present.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.ClassCastException</code> - if the stored value is not null and does not match <code>type</code>.</dd>
</dl>
</li>
</ul>
<a id="enableStackTraceComments(boolean)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>enableStackTraceComments</h4>
<pre class="methodSignature">public final&nbsp;<a href="AbstractCodeWriter.html" title="type parameter in AbstractCodeWriter">T</a>&nbsp;enableStackTraceComments&#8203;(boolean&nbsp;enableStackTraceComments)</pre>
<div class="block">Enable or disable writing stack trace comments before each call to
 <a href="#write(java.lang.Object,java.lang.Object...)"><code>write(java.lang.Object, java.lang.Object...)</code></a>, <a href="#writeWithNoFormatting(java.lang.Object)"><code>writeWithNoFormatting(java.lang.Object)</code></a>, <a href="#writeInline(java.lang.Object,java.lang.Object...)"><code>writeInline(java.lang.Object, java.lang.Object...)</code></a>,
 and <a href="#writeInlineWithNoFormatting(java.lang.Object)"><code>writeInlineWithNoFormatting(java.lang.Object)</code></a>.

 <p>It's sometimes useful to know where in a code generator a line of code
 generated text came from. Enabling stack trace comments will output
 the last relevant stack trace information caused text to appear in the
 code writer's output.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>enableStackTraceComments</code> - Set to true to enable stack trace comments.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns self.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
