/*
 * Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package software.amazon.smithy.rulesengine.language.eval;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Optional;
import software.amazon.smithy.rulesengine.language.EndpointRuleSet;
import software.amazon.smithy.rulesengine.language.error.RuleError;
import software.amazon.smithy.rulesengine.language.eval.value.EndpointValue;
import software.amazon.smithy.rulesengine.language.eval.value.Value;
import software.amazon.smithy.rulesengine.language.syntax.Identifier;
import software.amazon.smithy.rulesengine.traits.EndpointTestCase;
import software.amazon.smithy.rulesengine.traits.EndpointTestExpectation;
import software.amazon.smithy.rulesengine.traits.ExpectedEndpoint;
import software.amazon.smithy.utils.SmithyUnstableApi;
import software.amazon.smithy.utils.StringUtils;

/**
 * Provides facilities for evaluating an endpoint rule-set and tests.
 */
@SmithyUnstableApi
public final class TestEvaluator {
    private TestEvaluator() {
    }

    /**
     * Evaluate the given rule-set and test case. Throws an exception in the event
     * the test case does not pass.
     *
     * @param ruleset  The rule-set to be tested.
     * @param testCase The test case.
     */
    public static void evaluate(EndpointRuleSet ruleset, EndpointTestCase testCase) {
        Map<Identifier, Value> map = new LinkedHashMap<>();
        testCase.getParams().getStringMap().forEach((s, node) -> {
            map.put(Identifier.of(s), Value.fromNode(node));
        });
        Value got = RuleEvaluator.evaluate(ruleset, map);
        RuleError.context(
                String.format("while executing test case%s", Optional
                        .ofNullable(testCase.getDocumentation())
                        .map(d -> " " + d)
                        .orElse("")),
                testCase,
                () -> evaluateExpectation(testCase.getExpect(), got)
        );
    }

    private static void evaluateExpectation(EndpointTestExpectation want, Value got) {
        if (!(want.getEndpoint().isPresent() || want.getError().isPresent())) {
            throw new RuntimeException("Unhandled endpoint test case want.");
        }
        if (want.getEndpoint().isPresent()) {
            ExpectedEndpoint wantEndpoint = want.getEndpoint().get();

            EndpointValue.Builder builder = EndpointValue.builder()
                    .url(wantEndpoint.getUrl())
                    .headers(wantEndpoint.getHeaders());

            wantEndpoint.getProperties().forEach((s, node) -> {
                builder.putProperty(s, Value.fromNode(node));
            });

            EndpointValue wantValue = builder.build();

            if (!got.expectEndpointValue().equals(wantValue)) {
                throw new AssertionError(
                        String.format("Expected endpoint:%n%s but got:%n%s (generated by %s)",
                                StringUtils.indent(wantEndpoint.toString(), 2),
                                StringUtils.indent(got.toString(), 2),
                                wantEndpoint.getSourceLocation()));
            }
        } else {
            String wantError = want.getError().get();
            RuleError.context("While checking endpoint test (expecting an error)", () -> {
                if (!got.expectStringValue().getValue().equals(wantError)) {
                    throw new AssertionError(String.format("Expected error `%s` but got `%s`", wantError, got));
                }
            });
        }
    }
}
